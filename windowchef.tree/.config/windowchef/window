#!/usr/bin/dash
# sdothum - 2016 (c) wtfpl
# [ $TRACE ] && CHILD="window $@" . $PARENT

# Windowchef
# ══════════════════════════════════════════════════════════════════════════════

# ............................................................ Window operations

# Usage: window <msg>,      SEE: functions/window
#               @<delay> <msg>
#               @[<class> | <name>] [URL] <msg>
#                    where, @   wait for delay time or visible window
#                           URL indicates the spawned window name is a URL (even if <class> is defined)
#                           SEE: web/qutebrowser-instance, windowchef/rulerrc

# usable screen dimensions
margin=$(chef screen margin)
panel=$(chef screen panel)
top=$(chef screen top)            # windowchefrc panel height is default bottom gap_width
gap=$(chef screen gap)
W=$(( $(chef display width) - margin * 2 ))
H=$(( $(chef display height) - panel - top ))
recipe -q panel/top && top=$panel  # see draw panel

# Windowchef window geometry
border=$(chef screen window_border)
winid=$(pfw 2>/dev/null) || exit  # trap early window initialization and autostart rulerrc (to hide log chatter)
# xdotool windowstate --remove fullscreen $winid  # fullscreen negates any attempted window actions

geometry()       { xdotool getwindowgeometry --shell ${1:-$winid}; }             # X Y WIDTH HEIGHT (doesn't include borders)
set_geometry()   { eval $(geometry ${1:-$winid}); }
cat_geometry()   { [ -e $WINFO/$winid ] && eval $(ls -1 $WINFO/$winid) || exit 1; }
save_geometry()  { rm -rf $WINFO/${1:-$winid}; for x in $(geometry ${1:-$winid}) ;do mkdir -p $WINFO/${1:-$winid}/$x ;done }  # for revert
opposite_side()  { echo $(( width + margin * 2 - (X + WIDTH + border * 2) )); }  # for nearest edge SEE: window snap / stretch
windowfocus_by() { xdotool search -sync -onlyvisible -$1 "$xname" windowfocus; }
xname_is()       { xdotool getwindow$1 $winid | grep -q "$xname"; }

# ..................................................................... X Y size

# draw <winid> <width> <height> [rotate]
draw() {
	save_geometry
	[ $4 ] && { WID=$3; HGT=$2; } || { WID=$2; HGT=$3; }
	[ $HGT -gt $HEIGHT ] && { swap=$WID; WID=$HGT; HGT=$swap; }
	wtp $X $Y $WID $HGT $1
}

# do we need to wait longer for window creation?
if [ "$1" ] && [ -z "${1%%@*}" ] ;then
	case $1 in
		@[0-9.]* ) sleep ${1#@} ;;

		*        )
			xname="${1#@}"
			if [ $2 = 'URL' ] ;then
				case $1 in
					@*\ * ) windowfocus_by name      ;;
					@*    ) windowfocus_by classname ;;
				esac
				shift
			elif xname_is classname ;then
				windowfocus_by classname
			elif xname_is name ;then
				windowfocus_by name
			else
				return 1  # not expected window
			fi
			;;
	esac
	winid=$(pfw)
	shift
fi

msg=$1
[ $msg ] && shift || usage $0
if [ -e ${0%/window}/functions/window/$msg ] ;then
	. ${0%/window}/functions/window/$msg $@
else
	usage $0 $msg
fi

mapw -m $winid  # regain focus

# kak: filetype=sh
