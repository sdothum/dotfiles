#!/usr/bin/dash
# sdothum - 2016 (c) wtfpl

# Edit
# ══════════════════════════════════════════════════════════════════════════════

# ........................................................... helix pipe actions

usage() { echo "<selection> | $(basename $0) [<nth>] ')' | '{' | '|' | '&' | '=' | '#' | '//' | '||' | '&&' | ';;' | <string>
>   where, 'pattern' -> ' pattern '
>          '#'       -> '  # ' (appended comment)
>          ''        -> ' '    (nth <space>* column)
>          <string>  -> ' <string>'
>          tabstop   -> ${TABSTOP:-3}" | usage:pipe
	exit 1
}

LINES=/tmp/align:stdin
tabstop=${TABSTOP:-3}

delim='⁋'    # split char
dollar='¢'   # hard char to avoid "echo" loss
tab=$(for i in $(seq $tabstop) ;do echo -n "‣" ;done )  # hard char to avoid "echo" loss
nth=1        # pattern position
gutter=' '   # pattern gutter prefix
ignore='❌'  # nth space column split case avoidance (see below)

# simplified source code alignment extension using helix pipe
[ $1 ] || usage
[[ $1 =~ '^[0-9]+$' ]] && { nth=$1; shift; }

case "$1" in
	')'  ) match=$1; ignore="()" ;;  # align case pattern ')'
	'{'  ) match=$1; ignore="{}" ;;  # align single line f() '{'
	'||' ) match=$1 ;;
	'&&' ) match=$1 ;;
	';;' ) match=$1 ;;
	'|'  ) match=$1 ;;
	'&'  ) match=$1 ;;
	'='  ) match=$1 ;;
	'#'  ) match=$1; gutter='  ' ;;
	'//' ) match=$1; gutter='  ' ;;
	*    ) match=" " ;;  # force drop through (below)
esac

# insert split char and mark special chars ins
case "$1" in
	"$ignore" ) sed "/^[^${ignore}]*)/s/ *$match */$delim$gutter$match /" ;;
	"#"       ) sed -r "s/^( *$match*.*[^ ]) *$match */\1$delim$gutter$match /$nth" ;;    # ignore leading #
	"//"      ) sed -r "s|^( *($match)*.*[^ ]) *$match *|\1$delim$gutter$match |$nth" ;;  # ignore leading //
	"$match"  ) sed "s/ *$match */$delim$gutter$match /$nth" ;;
	''        ) sed "s/  */$delim /$nth" ;;    # align by spaces
	*         ) sed "s/$1/$delim $1/$nth" ;;   # align by string
esac | sed "s/\t/$tab/g; s/[$]/$dollar/g" >$LINES

# max left part width
max=0
while read line <&3 ;do
	if echo "$line" | grep -q "$delim" ;then
		len=$(echo "$line" | sed "s/${delim}.*//" | wc -m)  # wc by chars NOT bytes
		[ $len -gt $max ] && max=$len
	fi
done 3< $LINES

# pad align left/right parts and restore special chars
while read line <&3 ;do
	if echo "$line" | grep -q "$delim" ;then
		left=$(echo "$line" | sed "s/${delim}.*//")
		pad=$(( $max - $(echo "$left" | wc -m) ))
		pad=$(for i in $(seq $pad) ;do echo -n " " ;done )
		right=$(echo "$line" | sed "s/.*$delim//")
		echo "$left$pad$right"
	else
		echo "$line"
	fi
done 3< $LINES | sed "s/$tab/\t/g; s/$dollar/$/g"

# vim: set ft=sh: #
