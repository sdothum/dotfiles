#!/usr/bin/dash
# sdothum - 2016 (c) wtfpl

# Shell
# ══════════════════════════════════════════════════════════════════════════════

# ................................................................ Usage message

# Usage: .. | usage: [ $0 | "<command> <description>" ]
#        $0 assumes dir/script/functions/script folder hierarchy
#        "[[^ ] | < | >] <description>"* | usage:
#           <multiline pipe content> contains "[>]<command> <description>" with successive lines..
#              [^ ]  -> print below "command"
#              "< "  -> print below "command" (prevent leading space hard tab insertions while editing script)
#              "> "  -> print indented after "command"
#              ">> " -> print indented after "command name", e.g. "make_install iosevka" ..
#              >command in first line indicates "command name" (double word invocation)

USAGE=/tmp/usage:content

if [ "$1" ] ;then
	if [ -e "$1" ] ;then
		name=$(basename $1)
		message="$name $(ls -1 $(dirname $1)/functions/$name | tr '\n' ' ' | sed 's/ $//; s/ / \| /g')"
		echo "${BROWN}Usage: ${WHITE}$(echo "${message:-$1}" | sed -r "s/^ *([^ ]+ )/\1${cyan}/")${NOCOLOR}"
		exit
	else
		echo "$1" >$USAGE
	fi
else
	cat >$USAGE
fi

command=$(head -1 $USAGE | cut -d' ' -f1 | sed 's/^>//')
indent=$(echo $command | sed 's/./ /g')
if $(head -1 $USAGE | grep -q '^>') ;then  # >dot command
	command=$(head -1 $USAGE | cut -d' ' -f1-2 | sed 's/^>//')
	indents=$(echo $command | sed 's/./ /g')
fi
echo "${BROWN}Usage: $(cat $USAGE | sed -r "1s/^>//; s/($command )/${WHITE}\1${cyan}/g; s/^> /$indent /; s/^>> /$indents /; s/^< /  /g; s/^/       /g; 1s/^ *//;")"

exit 1  # must still exit from parent process

# vim: set ft=sh: #
