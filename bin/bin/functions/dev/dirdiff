#!/usr/bin/dash
# sdothum - 2016 (c) wtfpl

# Dev
# ══════════════════════════════════════════════════════════════════════════════

# ..................................................... Recursive directory diff

usage() { usage: "$(basename $0) [-[1 | s | b | E | Z | EZ]] [-d <date>] <source> [<target>] [<regex>]"; exit 1; }

# ignore='backups|debian|\.history|makepkg|nixos|plugged-custom|qmk_firmware|root|snippets|undo|vps'
ignore='backups|debian|\.history|makepkg|nixos|plugged-custom|root|snippets|undo|vps'

DOTFILES=/home/depot/dotfiles  # default target (find matching source path)
DIRDIFF=/tmp/dirdiff
FILES=$DIRDIFF:files
LOG=$DIRDIFF.log
if exists icdiff ;then
	IC=ic
	ICOPT='--line-numbers --truncate --tabsize=3 --color-map=add:red_bold,change:red_bold,subtract:red_bold,line-numbers:black_bold,separator:yellow'  # side-by-side
fi
delay=0.15  # match message viewing interval

while [ "$1" ] ;do
	case $1 in
		-1  ) unset IC ICOPT ;;                                        # standard diff (not side-by-side)
		-s  ) S=true         ;;                                        # stagger match message
		-b  ) w=-w; diffopt='set diffopt+=iwhite'  ;;                  # ignore whitespace
		-E  ) w=-E; diffopt='set diffopt+=iwhite'  ;;                  # ignore whitespace
		-Z  ) w=-Z; diffopt='set diffopt+=iwhite'  ;;                  # ignore whitespace
		-EZ ) w=-EZ; diffopt='set diffopt+=iwhite' ;;                  # ignore whitespace
		-d  ) FILTER=$DIRDIFF:filter; touch -d "$2" $FILTER; shift ;;  # timestamp filter
		*   ) break ;;
	esac
	shift
done

while [ "$1" ] ;do
	[ -d "$1" ] && { [ "$source" ] && target=$1 || source=$1; } || regex=$1
	shift
done
[ "$target" ] && [ "${target%${target#?*}}" != '/' ] && target=$PWD/$target  # target must be full pathname
[ -d "$target/${source##*/}" ] && target="$target/${source##*/}"

[ -d "$source" ] && cd "$source" || usage
source=$(pwd)
# unprovided target defaults to last git dotfile repo "pull"
if [ -d "$target" ] ;then
	[ -L $DOTFILES ] && L=-L
	target=$(find $L $DOTFILES -type d -regex ".*${source#$HOME}" 2>/dev/null | head -1)
	[ -d "$target" ] || target=$(find $L $DOTFILES -type d -regex ".*${source#$HOME/stow}" 2>/dev/null | head -1)
	# distinguish $HOME/bin from all other application bin folders
	case "${source#$HOME/}" in
		bin          ) target="$DOTFILES/bin/bin" ;;
		stow/bin     ) target="$DOTFILES/bin"     ;;
		stow/bin/bin ) target="$DOTFILES/bin/bin" ;;
	esac
fi
[ -d "$target" ] || usage
[ "$regex"  ] || regex='.*'

# to handle filenames containing spaces
find -L ./ -type f | exclude | grep -E -v $ignore | grep "$regex" >$FILES
[ -s $FILES ] || usage
src=${source#$HOME/stow/*/}
src=\~/${src#$HOME/}
target=${target%//.}  # trim unnecessary directory placeholders (depending on command line input)
target=${target%/.}

while read file <&3 ;do
	[ ${file##*.} = 'log' ] || [ ${file##*.} = 'jpg' ] && continue
	file $file | grep -q text || { ditto skipping "$file"; continue; }
	unset blink
	targetfile="${target}/${file#./}"
	while : ;do
		[ $FILTER ] && [ "$file" -ot $FILTER ] && break
		clear
		file="${file#./}"
		[ $title ] || { ditto -t diff "$src/$regex && $target" >>$LOG; title=true; }
		[ -e "${targetfile}" ] || { ditto ERROR missing "${targetfile}" >>$LOG; break; }
		if ! diff --brief $w "${file}" "${targetfile}" >/dev/null 2>&1 ;then
			ditto diff "${file}"
			${IC}diff ${ICOPT} $w "${file}" "${targetfile}" | colordiff | pager  # SEE: ~/.colordiffrc
			# ifno "edit ${file}" && break || vim -g -d -c "$diffopt" -f --role=gvimdiff "${file}" "${targetfile}"  # vim deprecated
			ifno "edit ${file}" && break
			kakdiff "${file}" "${targetfile}"  # kak diff
			blink=${BLINK}
		else
			ditto match "${file}"
			[ $S ] && sleep $delay
			break
		fi
	done
done 3< $FILES

# kak: filetype=sh
